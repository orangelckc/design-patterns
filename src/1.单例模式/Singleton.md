# 单例模式

> Ensure a class has only one instance, and provide a global point of access to it.

确保一个类只有一个实例，并提供一个访问该实例的全局节点。

- [参考教程](https://refactoringgurucn/design-patterns/singleton)
- [视频讲解](https://www.bilibili.com/video/BV1af4y1y7sS/?vd_source=7712ed3b76310965950f07339f9013b5)


## 要求

1. 构造方法必须是私有的，防止外部直接实例化
2. 实例是当前类的静态属性，保证全局唯一
3. 提供一个静态方法，获取当前类的实例

## 优点

1. 保证全局唯一，例如：序列号生成器、线程池、全局缓存、浏览器中的 window 对象
2. 避免频繁创建销毁对象，提高性能，例如：数据库连接池、网站计数器

## 缺点

1. 没有接口，扩展困难
2. 与单一职责原则冲突，一个类只负责一件事，但是单例模式却要负责创建和管理自己的实例

## 懒汉式

[code](./%E6%87%92%E6%B1%89%E5%BC%8F.ts)

懒汉式是指全局的单例实例在第一次被调用时构建。

但是，这种实现方式有个缺点，就是不能保证线程安全。即：当多个线程同时调用 getInstance() 方法时，可能会产生多个实例。

为了解决这个问题，我们可以对 getInstance() 方法加锁，但是这样做会影响程序的性能。因为每次调用 getInstance() 方法时，都要对对象上锁，即使 instance 已经被实例化了，这也会导致不必要的同步开销。

所以，不推荐使用这种实现方式。

## 饿汉式

[code](./%E9%A5%BF%E6%B1%89%E5%BC%8F.ts)

饿汉式是指全局的单例实例在类装载时构建。

这种方式比懒汉式更好，因为它天生就是线程安全的；它可以在多线程环境下正常工作，而懒汉式不能。

但是，这种实现方式有个缺点，就是不能保证单例对象的延迟加载。因为单例对象在类装载时就进行了初始化，如果从始至终从未使用过这个单例对象，那么它将造成内存的浪费。

## 代理实现单例模式

[code](./%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0.ts)

代理模式是一种结构型设计模式，它能为其他对象提供一种代理以控制对这个对象的访问。

代理模式的主要优点如下。

1. 代理模式能将代理对象与真实被调用的目标对象分离。
2. 一定程度上降低了系统的耦合度，扩展性好。
3. 保护目标对象。
4. 增强目标对象。

代理模式的主要缺点如下。

1. 代理模式会造成系统设计中类的数目增加。
2. 在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢。
3. 增加了系统的复杂度。

抽象工厂模式、 生成器模式和原型模式都可以用单例来实现。